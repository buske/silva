#!/usr/bin/env python

"""
Input file should be in the 8+ column format generated by SilVA.

GENE_CACHE is the cache file generated by SilVA that contains 
transcriptome sequences.

Uses fas-hex3.txt in same directory to identify putative exonic
splice enhancers (ESSs) based upon hexamer subsequences.
"""

# Author: Orion Buske
# Date:   27 December 2011

from __future__ import division, with_statement

import os
import sys
import re

assert os.getenv('SILVA_PATH') is not None, \
       "Error: SILVA_PATH is unset."
sys.path.insert(0, os.path.expandvars("$SILVA_PATH/lib/python"))
from silva import maybe_gzip_open, print_args, get_genes, iter_mutation_seqs

def hexamer_subsequences(hexs, seq):
    """Return dict: pos -> hexamer found in seq"""
    found = dict()
    motif_len = 6  # hexamers
    for offset in xrange(0, len(seq) - motif_len + 1):
        target_seq = seq[offset: offset + motif_len]
        if target_seq in hexs:
            found[offset] = target_seq

    return found

def score_mutation(hexs, old_seq, new_seq):
    """Return differences in hex hits between new and old sequences
    @return: (number of hexamers lost, number of hexamers gained)
    """
    # hexamer_subsequences returns dict of {pos: hexamer}
    old = hexamer_subsequences(hexs, old_seq)
    new = hexamer_subsequences(hexs, new_seq)
    old_pos = set(old)
    new_pos = set(new)
    return len(old_pos - new_pos), len(new_pos - old_pos)

def read_hexamers(filename):
    hexs = []
    with open(filename) as ifp:
        for line in ifp:
            line = line.strip()
            if line:
                if len(line) == 6:
                    hexs.append(line)
                else:
                    print >>sys.stderr, "Found invalid hexamer: %s" % line
    return set(hexs)

def script(gene_cache, filename, hex_filename='fas-hex3.txt', quiet=False, **kwargs):
    hexs = read_hexamers(hex_filename)
    genes = get_genes(cache_filename=gene_cache)
    fields = ['FAS6-', 'FAS6+']
    if quiet:
        print '#%s' % '\t'.join(fields)
        NULL = '\t'.join(['na'] * len(fields))
    else:
        print '#n_initial n_lost n_gained'
        NULL = 'na na na'
        
    def safe_div(num, denom):
        if num + denom > 0:
            return '%.4f' % (num / (num + denom))
        else:
            return 'na'
                
    for exon, old, new in iter_mutation_seqs(filename, genes, left=5, right=5):
        n_old = len(hexamer_subsequences(hexs, exon))
        n_lost, n_gained = score_mutation(hexs, old, new)

        if quiet:
            print '\t'.join([safe_div(n_lost, n_old),
                             safe_div(n_gained, n_old)])
        else:
            print '%d\t%d\t%d' % (n_old, n_lost, n_gained)

def parse_args(args):
    from optparse import OptionParser
    usage = "usage: %prog [options] GENE_CACHE (SEQ|-)"
    description = __doc__.strip()
    
    parser = OptionParser(usage=usage,
                          description=description)
    parser.add_option("-q", "--quiet", default=False,
                      dest="quiet", action='store_true',
                      help="Quiet output, suitable"
                      " for additional processing")
    options, args = parser.parse_args()

    if len(args) != 2:
        parser.error("Inappropriate number of arguments")

    return options, args

def main(args=sys.argv[1:]):
    options, args = parse_args(args)
    kwargs = dict(options.__dict__)

    if not options.quiet:
        print_args(args, kwargs)
    script(*args, **kwargs)

if __name__ == '__main__':
    sys.exit(main())
