#!/usr/bin/env python

"""
Uses weights.txt in same directory to identify putative exonic
splice enhancers (ESEs). 

Input file should be in the 8+ column format generated by SilVA.

GENE_CACHE is the cache file generated by SilVA that contains
transcriptome sequences.
"""

# Author: Orion Buske
# Date:   27 December 2011

from __future__ import division, with_statement

import os
import sys

assert os.getenv('SILVA_PATH') is not None, \
       "Error: SILVA_PATH is unset."
sys.path.insert(0, os.path.expandvars("$SILVA_PATH/lib/python"))
from silva import maybe_gzip_open, print_args, get_genes, iter_mutation_seqs

PRE_LEN = 7
POST_LEN = 7

def read_weights(filename):
    with open(filename) as ifp:
        return eval(ifp.read())

def score_target(motif, target):
    assert len(target) == len(motif['A'])
    score = 0.0
    for i, nuc in enumerate(target):
        score += motif[nuc][i]
    return score

def score_sequence(matrix, seq):
    """Return dict: pos -> score for all motif hits above threshold"""
    motif = matrix['motif']
    threshold = matrix['threshold']
    motif_len = len(motif['A'])

    hits = {}
    for offset in xrange(0, len(seq) - motif_len + 1):
        target_seq = seq[offset: offset + motif_len]
        score = score_target(motif, target_seq)
        if score >= threshold:
            hits[offset] = score

    return hits

def score_mutation(matrix, old_seq, new_seq, verbose=False):
    """Return tuple (# motifs lost, # motifs gained)"""
    old = score_sequence(matrix, old_seq)
    new = score_sequence(matrix, new_seq)
    if verbose:
        print >>sys.stderr, "Old scores:", str(old)
        print >>sys.stderr, "New scores:", str(new)
        
    old_pos = set(old)
    new_pos = set(new)
    return len(old_pos - new_pos), len(new_pos - old_pos)
                    
def script(gene_cache, filename, weight_filename='weights.txt',
           quiet=False, verbose=False, **kwargs):
    weights = read_weights(weight_filename)
    genes = get_genes(cache_filename=gene_cache)
    fields = ['SR-', 'SR+']

    if quiet:
        print '#%s' % '\t'.join(fields)
        #NULL = '\t'.join(['na'] * 2)
    else:
        print "#PSSM  n_motifs  motif_loss  motif_gain"
        #NULL = '\t'.join(['na'] * 3)

    def safe_div(num, denom):
        if num + denom > 0:
            return '%.4f' % (num / (num + denom))
        else:
            return 'na'

    for exon, old, new in \
            iter_mutation_seqs(filename, genes, left=PRE_LEN, right=POST_LEN):
        tot = tot_lost = tot_gained = 0
        for name in sorted(weights):
            pssm = weights[name]
            n_old = len(score_sequence(pssm, exon))
            n_lost, n_gained = score_mutation(pssm, old, new,
                                              verbose=verbose)

            tot += n_old
            tot_lost += n_lost
            tot_gained += n_gained
            if not quiet:
                print "%s\t%d\t%d\t%d" % (name, tot, n_lost, n_gained)

        if quiet:
            # Only print totalled effects
            print '\t'.join([safe_div(tot_lost, tot),
                             safe_div(tot_gained, tot)])

def parse_args(args):
    from optparse import OptionParser
    usage = "usage: %prog [options] GENE_CACHE (SEQ|-)"
    description = __doc__.strip()
    
    parser = OptionParser(usage=usage,
                          description=description)
    parser.add_option("-q", "--quiet", default=False,
                      dest="quiet", action='store_true',
                      help="Print one line per sequence, suitable"
                      " for additional processing")
    parser.add_option("-v", "--verbose", default=False,
                      dest="verbose", action='store_true')
    options, args = parser.parse_args()

    if len(args) != 2:
        parser.error("Inappropriate number of arguments")

    return options, args

def main(args=sys.argv[1:]):
    options, args = parse_args(args)
    kwargs = dict(options.__dict__)

    if not options.quiet:
        print_args(args, kwargs)
    script(*args, **kwargs)

if __name__ == '__main__':
    sys.exit(main())
