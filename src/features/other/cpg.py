#!/usr/bin/env python

"""
Given a genomic DNA mutation, computes cpg-related features
including whether the mutation alters a CpG and the local
obs/exp CpG ratio.

Input file should be in the 8+ column format generated by SilVA.

GENE_CACHE is the cache file generated by SilVA that contains 
transcriptome sequences.
"""

# Author: Orion Buske
# Date:   29 December 2011

from __future__ import division, with_statement

import os
import sys

assert os.getenv('SILVA_PATH') is not None, \
           "Error: SILVA_PATH is unset."
sys.path.insert(0, os.path.expandvars('$SILVA_PATH/lib/python'))
from silva import maybe_gzip_open, print_args, get_genes, iter_mutation_seqs

def calc_cpg(seq):
    """Return obs/exp CpG
    
    Calculated using formula in:
    Gardiner-Garden M, Frommer M.
    CpG islands in vertebrate genomes.
    J. Mol. Biol. 1987 Jul 20;196(2):261-82.
    """
    denom = seq.count('C') * seq.count('G')
    if denom > 0:
        return seq.count('CG') * len(seq) / float(denom)
    else:
        return 0
                    
def script(gene_cache, filename, quiet=False, **kwargs):
    genes = get_genes(cache_filename=gene_cache)
    fields = ['CpG?', 'CpG_exon']
    NULL = '\t'.join(['na'] * 2)

    print '#%s' % '\t'.join(fields)
    for exon, old, new in iter_mutation_seqs(filename, genes, left=1, right=1):
        # Was a CpG created or destroyed by the mutation?
        if not (len(old) == len(new) == 3 and old[0] == new[0]):
            print >>sys.stderr, "Warning: mutation at edge of pre-mRNA"
            print NULL
            continue

        pre = old[0]
        post = old[2]
        old = old[1]
        new = new[1]

        mut_cpg = bool((pre == 'C' and (old == 'G' or new == 'G')) or 
                       (post == 'G' and (old == 'C' or new == 'C')))

        cpg_exon = calc_cpg(exon)
        print '%d\t%.4f' % (mut_cpg, cpg_exon)

def parse_args(args):
    from optparse import OptionParser
    usage = "usage: %prog [options] GENE_CACHE (SEQ|-)"
    description = __doc__.strip()
    
    parser = OptionParser(usage=usage,
                          description=description)
    parser.add_option("-q", "--quiet", default=False,
                      dest="quiet", action='store_true',
                      help="Quiet output, suitable"
                      " for additional processing")
    options, args = parser.parse_args()

    if len(args) != 2:
        parser.error("Inappropriate number of arguments")

    return options, args

def main(args=sys.argv[1:]):
    options, args = parse_args(args)
    kwargs = dict(options.__dict__)

    if not options.quiet:
        print_args(args, kwargs)
    script(*args, **kwargs)

if __name__ == '__main__':
    sys.exit(main())
